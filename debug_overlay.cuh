/**
 * debug_overlay.cuh - Sistema di Debug Overlay
 * 
 * Questo file gestisce la visualizzazione a schermo delle informazioni
 * di debug: FPS, informazioni GPU, posizione camera, ecc.
 * 
 * PERCHÉ SERVE:
 * =============
 * Durante lo sviluppo di un raytracer (o qualsiasi applicazione grafica)
 * è fondamentale avere feedback immediato su:
 * - Performance (FPS)
 * - Stato della GPU
 * - Parametri della camera
 * - Modalità di rendering attiva
 * 
 * COME FUNZIONA:
 * ==============
 * 1. Usiamo OpenGL in modalità 2D (ortografica) per disegnare sopra la scena
 * 2. Ogni carattere viene disegnato come una griglia di pixel (font bitmap 5x7)
 * 3. Un pannello semi-trasparente fa da sfondo per leggibilità
 */

#ifndef DEBUG_OVERLAY_CUH
#define DEBUG_OVERLAY_CUH

// NOTA: Gli include di GL/glew.h e GLFW devono essere fatti nel file principale
// prima di questo header!

/**
 * Struttura per memorizzare le informazioni della GPU
 * 
 * Queste informazioni vengono lette una sola volta all'avvio
 * tramite cudaGetDeviceProperties() e cudaDeviceGetAttribute().
 */
struct GPUInfo {
    char name[256];               // Nome della GPU (es. "NVIDIA RTX 2050")
    int computeCapabilityMajor;   // Versione CC maggiore (es. 7 per RTX 20xx)
    int computeCapabilityMinor;   // Versione CC minore (es. 5 per RTX 2050)
    int multiProcessorCount;      // Numero di Streaming Multiprocessors (SM)
    size_t totalGlobalMem;        // VRAM totale in bytes
    int maxThreadsPerBlock;       // Max thread per blocco CUDA (tipicamente 1024)
    int maxThreadsPerMP;          // Max thread per SM
    int clockRateMHz;             // Frequenza GPU in MHz
    int sharedMemPerBlock;        // Shared memory per blocco in bytes
    int warpSize;                 // Dimensione warp (32 per GPU NVIDIA)
};

/**
 * FONT BITMAP 5x7
 * ===============
 * 
 * Un font bitmap è il modo più semplice per disegnare testo:
 * - Ogni carattere è una matrice di pixel
 * - 5 colonne x 7 righe = 35 pixel per carattere
 * - Ogni colonna è memorizzata come un byte (7 bit usati)
 * 
 * Esempio: La lettera 'A' (ASCII 65):
 * 
 *   01234  ← colonne
 *  ┌─────┐
 * 0│ ███ │
 * 1│█   █│
 * 2│█   █│
 * 3│█████│
 * 4│█   █│
 * 5│█   █│
 * 6│█   █│
 *  └─────┘
 *   ↑ righe
 * 
 * Memorizzato come: {0x7E, 0x11, 0x11, 0x11, 0x7E}
 * 
 * Colonna 0: 0x7E = 01111110 → righe 1,2,3,4,5,6 accese
 * Colonna 1: 0x11 = 00010001 → righe 0,4 accese
 * ecc.
 */

// Font bitmap 5x7 per caratteri ASCII 32-126
// Ogni carattere è definito da 5 byte, uno per colonna
static const unsigned char font5x7[][5] = {
    {0x00,0x00,0x00,0x00,0x00}, // 32 space
    {0x00,0x00,0x5F,0x00,0x00}, // 33 !
    {0x00,0x07,0x00,0x07,0x00}, // 34 "
    {0x14,0x7F,0x14,0x7F,0x14}, // 35 #
    {0x24,0x2A,0x7F,0x2A,0x12}, // 36 $
    {0x23,0x13,0x08,0x64,0x62}, // 37 %
    {0x36,0x49,0x55,0x22,0x50}, // 38 &
    {0x00,0x05,0x03,0x00,0x00}, // 39 '
    {0x00,0x1C,0x22,0x41,0x00}, // 40 (
    {0x00,0x41,0x22,0x1C,0x00}, // 41 )
    {0x08,0x2A,0x1C,0x2A,0x08}, // 42 *
    {0x08,0x08,0x3E,0x08,0x08}, // 43 +
    {0x00,0x50,0x30,0x00,0x00}, // 44 ,
    {0x08,0x08,0x08,0x08,0x08}, // 45 -
    {0x00,0x60,0x60,0x00,0x00}, // 46 .
    {0x20,0x10,0x08,0x04,0x02}, // 47 /
    {0x3E,0x51,0x49,0x45,0x3E}, // 48 0
    {0x00,0x42,0x7F,0x40,0x00}, // 49 1
    {0x42,0x61,0x51,0x49,0x46}, // 50 2
    {0x21,0x41,0x45,0x4B,0x31}, // 51 3
    {0x18,0x14,0x12,0x7F,0x10}, // 52 4
    {0x27,0x45,0x45,0x45,0x39}, // 53 5
    {0x3C,0x4A,0x49,0x49,0x30}, // 54 6
    {0x01,0x71,0x09,0x05,0x03}, // 55 7
    {0x36,0x49,0x49,0x49,0x36}, // 56 8
    {0x06,0x49,0x49,0x29,0x1E}, // 57 9
    {0x00,0x36,0x36,0x00,0x00}, // 58 :
    {0x00,0x56,0x36,0x00,0x00}, // 59 ;
    {0x00,0x08,0x14,0x22,0x41}, // 60 <
    {0x14,0x14,0x14,0x14,0x14}, // 61 =
    {0x41,0x22,0x14,0x08,0x00}, // 62 >
    {0x02,0x01,0x51,0x09,0x06}, // 63 ?
    {0x32,0x49,0x79,0x41,0x3E}, // 64 @
    {0x7E,0x11,0x11,0x11,0x7E}, // 65 A
    {0x7F,0x49,0x49,0x49,0x36}, // 66 B
    {0x3E,0x41,0x41,0x41,0x22}, // 67 C
    {0x7F,0x41,0x41,0x22,0x1C}, // 68 D
    {0x7F,0x49,0x49,0x49,0x41}, // 69 E
    {0x7F,0x09,0x09,0x01,0x01}, // 70 F
    {0x3E,0x41,0x41,0x51,0x32}, // 71 G
    {0x7F,0x08,0x08,0x08,0x7F}, // 72 H
    {0x00,0x41,0x7F,0x41,0x00}, // 73 I
    {0x20,0x40,0x41,0x3F,0x01}, // 74 J
    {0x7F,0x08,0x14,0x22,0x41}, // 75 K
    {0x7F,0x40,0x40,0x40,0x40}, // 76 L
    {0x7F,0x02,0x04,0x02,0x7F}, // 77 M
    {0x7F,0x04,0x08,0x10,0x7F}, // 78 N
    {0x3E,0x41,0x41,0x41,0x3E}, // 79 O
    {0x7F,0x09,0x09,0x09,0x06}, // 80 P
    {0x3E,0x41,0x51,0x21,0x5E}, // 81 Q
    {0x7F,0x09,0x19,0x29,0x46}, // 82 R
    {0x46,0x49,0x49,0x49,0x31}, // 83 S
    {0x01,0x01,0x7F,0x01,0x01}, // 84 T
    {0x3F,0x40,0x40,0x40,0x3F}, // 85 U
    {0x1F,0x20,0x40,0x20,0x1F}, // 86 V
    {0x7F,0x20,0x18,0x20,0x7F}, // 87 W
    {0x63,0x14,0x08,0x14,0x63}, // 88 X
    {0x03,0x04,0x78,0x04,0x03}, // 89 Y
    {0x61,0x51,0x49,0x45,0x43}, // 90 Z
    {0x00,0x00,0x7F,0x41,0x41}, // 91 [
    {0x02,0x04,0x08,0x10,0x20}, // 92 backslash
    {0x41,0x41,0x7F,0x00,0x00}, // 93 ]
    {0x04,0x02,0x01,0x02,0x04}, // 94 ^
    {0x40,0x40,0x40,0x40,0x40}, // 95 _
    {0x00,0x01,0x02,0x04,0x00}, // 96 `
    {0x20,0x54,0x54,0x54,0x78}, // 97 a
    {0x7F,0x48,0x44,0x44,0x38}, // 98 b
    {0x38,0x44,0x44,0x44,0x20}, // 99 c
    {0x38,0x44,0x44,0x48,0x7F}, // 100 d
    {0x38,0x54,0x54,0x54,0x18}, // 101 e
    {0x08,0x7E,0x09,0x01,0x02}, // 102 f
    {0x08,0x14,0x54,0x54,0x3C}, // 103 g
    {0x7F,0x08,0x04,0x04,0x78}, // 104 h
    {0x00,0x44,0x7D,0x40,0x00}, // 105 i
    {0x20,0x40,0x44,0x3D,0x00}, // 106 j
    {0x00,0x7F,0x10,0x28,0x44}, // 107 k
    {0x00,0x41,0x7F,0x40,0x00}, // 108 l
    {0x7C,0x04,0x18,0x04,0x78}, // 109 m
    {0x7C,0x08,0x04,0x04,0x78}, // 110 n
    {0x38,0x44,0x44,0x44,0x38}, // 111 o
    {0x7C,0x14,0x14,0x14,0x08}, // 112 p
    {0x08,0x14,0x14,0x18,0x7C}, // 113 q
    {0x7C,0x08,0x04,0x04,0x08}, // 114 r
    {0x48,0x54,0x54,0x54,0x20}, // 115 s
    {0x04,0x3F,0x44,0x40,0x20}, // 116 t
    {0x3C,0x40,0x40,0x20,0x7C}, // 117 u
    {0x1C,0x20,0x40,0x20,0x1C}, // 118 v
    {0x3C,0x40,0x30,0x40,0x3C}, // 119 w
    {0x44,0x28,0x10,0x28,0x44}, // 120 x
    {0x0C,0x50,0x50,0x50,0x3C}, // 121 y
    {0x44,0x64,0x54,0x4C,0x44}, // 122 z
    {0x00,0x08,0x36,0x41,0x00}, // 123 {
    {0x00,0x00,0x7F,0x00,0x00}, // 124 |
    {0x00,0x41,0x36,0x08,0x00}, // 125 }
    {0x08,0x08,0x2A,0x1C,0x08}, // 126 ~
};

/**
 * Disegna un singolo carattere
 * 
 * @param x - Posizione X (pixel)
 * @param y - Posizione Y (pixel)
 * @param c - Il carattere da disegnare
 * @param scale - Fattore di scala (2.0 = doppia dimensione)
 * 
 * FUNZIONAMENTO:
 * 1. Ottiene l'indice del carattere nella tabella font5x7
 * 2. Per ogni colonna (0-4):
 *    - Per ogni riga (0-6):
 *      - Se il bit è 1, disegna un quadrato
 */
inline void drawChar(float x, float y, char c, float scale) {
    if (c < 32 || c > 126) return;  // Caratteri non supportati
    int idx = c - 32;  // Offset nella tabella (space = indice 0)
    
    for (int col = 0; col < 5; col++) {
        unsigned char colData = font5x7[idx][col];
        for (int row = 0; row < 7; row++) {
            // Controlla se il bit 'row' è impostato
            if (colData & (1 << row)) {
                // Calcola posizione del pixel
                float px = x + col * scale;
                float py = y + row * scale;
                // Disegna un quadratino
                glBegin(GL_QUADS);
                    glVertex2f(px, py);
                    glVertex2f(px + scale, py);
                    glVertex2f(px + scale, py + scale);
                    glVertex2f(px, py + scale);
                glEnd();
            }
        }
    }
}

/**
 * Disegna una stringa di testo
 * 
 * @param x - Posizione X iniziale
 * @param y - Posizione Y iniziale
 * @param str - La stringa da disegnare
 * @param scale - Fattore di scala
 * 
 * Supporta '\n' per andare a capo.
 */
inline void drawString(float x, float y, const char* str, float scale) {
    float startX = x;
    while (*str) {
        if (*str == '\n') {
            // A capo: torna a inizio riga e scendi
            y += 9 * scale;  // 7 righe + 2 di spaziatura
            x = startX;
        } else {
            drawChar(x, y, *str, scale);
            x += 6 * scale;  // 5 colonne + 1 di spaziatura
        }
        str++;
    }
}

#endif // DEBUG_OVERLAY_CUH
